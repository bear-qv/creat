var querystring = require('querystring');

var streamdo = function(req,data){
  if(req.headers['content-type']){
    var content = querystring.parse(req.headers['content-type'],'; ','=');
    var length   = req.headers['content-length'];
    if('application/x-www-form-urlencoded' in content){req = jsonparser(req,data)}
    if('multipart/form-data' in content){req = fileparser(req,data)}
    
    //json流
    function jsonparser(req,data){
      content.charset = content.charset || 'UTF-8';
      data = data.toString(content.charset);
      req.postarr = querystring.parse(data,'&','=');
      return req;
    };
    //form流
    function fileparser(req,data){
      if(content.boundary){
        //声明前置变量
        var brcode = content.boundary;
        var br  = '\r\n';
        var header = '--'+brcode;
        arr = check(data,header);
        req.postarr = arr.post;
        req.files = arr.file;
      }
      return req;
    };
  };
  return req;
};

function  check(data,v){
  xv = v+'\r\n'
  x = new Buffer(xv);
  var len = x.length;
  var len2 = data.length;
  var chi = {};
  var chi2 ={};
  var k = data.slice(0, len);
  //验证boundary
  if(k.toString()==xv){    
    var result={};
    result.file={};
    result.post={};
    //正式解析部分
    //顺序解码
    ///去头
    data = data.slice(len,len2)
    //平整化尾部
    data = data.slice(0,data.length-4)
    var br = new Buffer('\r\n')
    data = Buffer.concat([data,br])
    ///顺序解析LSCF
    var arr;
    var len3;
    var len4;
    var st = 'h1';
    var filename;
    var name;
    //h1 解头行
    while (arr!='end'){
      if(arr !='end'){
        statu = st;
        //st1
        if(statu == 'h1'){
          arr = getnextbr(data);
          info = arr[0];
          data = arr[1];
          var cd = info.toString();
          cd  = querystring.parse(cd,'; ','=');
          name = cd['name'];
          if('filename' in cd){
            filename = cd['filename'];
            st = 'h3';
          }else{
            st = 'h2';
          }
        }
        //st2 postpath
        if(statu == 'h2'){
          arr = getnextbr(data);
          info = arr[0];
          data = arr[1];
          st = 'h6';
        }
        //st6
        if(statu == 'h6'){
          arr = getnextbr(data);
          info = arr[0];
          data = arr[1];
          result.post[name]=arr[0].toString();
          st = 'xp';
        }
        //st3 filepath
        if(statu == 'h3' || statu == 'h4'){
          arr = getnextbr(data);
          info = arr[0];
          data = arr[1];
          //jumpmime
          if(statu == 'h3'){st = 'h4'}
          if(statu == 'h4'){st = 'h5'}
        }
        
        //st5 filepath2
        if(statu == 'h5'){
          arr = getnextend(data,v);
          info = arr[0];
          data = arr[1];
          st = 'xp';
          if(arr[0].length!=0){
            result.file[name]={filename:filename,main:arr[0]};
          }
        }
        //xp
        if(statu == 'xp'){
          data = data.slice(len,data.length)
          if(data.length == 0){arr='end'}
          st = 'h1';
        }
        
      }
    }
  }
  return result;
};

function getnextbr(data){
  var i = 0;
  while(isbr(data,i)){
    i++
  }
    return [data.slice(0,i),data.slice(i+2,data.length)]
};

function getnextend(data,v){
  var i = 0;
  var keyx = '\r\n'+v;
  keyx = new Buffer(keyx);
  while(isend(data,i,keyx)){
    i++
  }
  return [data.slice(0,i),data.slice(i+2,data.length)]
};

function isbr(data,i){
  if(data[i]=='13' && data[i+1]=='10'){
    return false;
  }else{return true}
};

function isend(data,i,keyx){
  var lens = keyx.length;
  var pd = false;
  for(v=0;v<lens;v++){
   if(data[i+v] != keyx[v]){pd=true}
  }
  return pd;
};

exports = module.exports = streamdo;